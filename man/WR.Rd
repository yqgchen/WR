% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/WR.R
\name{WR}
\alias{WR}
\title{Wasserstein regression}
\usage{
WR(X, Y, qSup, optns = list(), FPCAoptnsX = list(), FPCAoptnsY = list())
}
\arguments{
\item{X}{A list whose elements consist of distributional predictors and/or scalar predictors. 
Each distributional predictor has to be represented by a \eqn{q}-by-\eqn{n} matrix 
whose columns consist of quantile functions of \eqn{n} realizations of this distributional predictor, 
which are evaluated on a common grid \code{qSup} on \eqn{[0,1]} consisting of \eqn{q} points. 
Each scalar predictor (if any) has to be represented by a vector of length \eqn{n}.}

\item{Y}{Distributional or scalar responses. 
A distributional response has to be represented by a \eqn{q}-by-\eqn{n} matrix 
whose columns consist of quantile functions of \eqn{n} realizations, 
which are evaluated on a common grid \code{qSup} on \eqn{[0,1]} consisting of \eqn{q} points. 
A scalar response has to be represented by a vector of length \eqn{n}.}

\item{qSup}{A vector of length \eqn{q} holding the common support grid of quantile functions, 
of which the elements are in a strictly increasing order and lie between 0 and 1.}

\item{optns}{A list of optional control parameters for regression specified by \code{list(name=value)}. See 'Details'.}

\item{FPCAoptnsX, FPCAoptnsY}{Lists of optional control parameters for functional principal 
component analysis (FPCA) of log mapped distributional predictors and responses, respectively. 
See 'Details' of \code{\link[fdapace]{FPCA}}. 
For example, one can specify the methods of choosing numbers of functional principal components (FPCs) 
through \code{methodSelectK} and set up Fraction-of-Variance-Explained (FVE) thresholds 
through \code{FVEthreshold} when using FVE to choose numbers of FPCs. 
Default of \code{methodSelectK}: \code{'FVE'}; 
Default of \code{FVEthreshold}: 0.95 (different from \code{\link[fdapace]{FPCA}}).
Default of \code{useBinnedData}: \code{'OFF'} (different from \code{\link[fdapace]{FPCA}}).}
}
\value{
A list of the following:
\item{Yfit}{Fitted responses; either a vector of length \eqn{n} for scalar responses 
or a \eqn{q}-by-\eqn{n} matrix holding the quantile functions for distributional responses, 
evaluated on \code{qSup}.}
\item{qSup}{The input \code{qSup}.}
\item{beta}{A list of fitted coefficient functions, 
\eqn{j}-th element corresponding to \eqn{j}-th predictor in \code{X}. 
Elements take the following form: 
(1) a scalar, if the response and the corresponding predictor are both scalar;
(2) a vector holding the fitted coefficient function evaluated on \code{workGridX}, 
if the response is scalar and the corresponding predictor is distributional;
(3) a vector holding the fitted coefficient function evaluated on \code{workGridY}, 
if the response is distributional and the corresponding predictor is scalar;
(4) a matrix holding the fitted coefficient function, where (\code{j},\code{k})-th entry 
holds the value evaluated at (\code{workGridX[j]},\code{workGridY[k]}), 
if the response and the corresponding predictor are both distributional.}
\item{workGridX}{A list of elements, 
which are either vectors holding a working grid for elements of \code{beta} for a distributional predictor, 
or \code{NULL} for a scalar predictor.}
\item{workGridY}{A vector holding a working grid for elements of \code{beta} for a distributional response; 
\code{NULL} for a scalar response.}
\item{fpcaLogX}{A list of FPCA objects holding the FPCA output for each log mapped distributional predictors; 
Or \code{NULL} if all the predictors are scalar.}
\item{fpcaLogY}{An FPCA object holding the FPCA output for log mapped responses if the responses are distributional;
\code{NULL} if the responses are scalar.}
\item{X}{The input \code{X}.}
\item{Y}{The input \code{Y}.}
\item{outOfLogSpace}{A logical vector holding whether initial fitted log mapped distributional responses 
lie out of the log image space (\code{TRUE}) or not (\code{FALSE}); 
\code{NULL} if the responses are scalar.}
\item{optns}{A list of options actually used.}
\item{FPCAoptnsX}{A list of FPCA options actually used for distributional predictors; 
\code{NULL} if all the predictors are scalar.}
\item{FPCAoptnsY}{A list of FPCA options actually used for distributional responses; 
\code{NULL} if the responses are scalar.}
}
\description{
Wasserstein regression with 
(1) distributional and/or scalar predictors and distributional responses, 
(2) distributional (and scalar) predictors and scalar responses.
}
\details{
Available control options are
\describe{
\item{methodProj}{
The projection method if the fitted values of log mapped distributional responses lie out of the log image space: 
\code{'log'} (the method as per Chen, Lin, and Müller, 2021); 
\code{'qt'} (default, the method as per Petersen & Müller, 2019).
}
\item{lower}{A scalar specifying the lower bound of the support of responses if 
they are distributional, only relevant if \code{methodProj} is \code{'qt'}. 
Default: \code{NULL}, i.e., no finite lower bound.}
\item{upper}{A scalar specifying the upper bound of of the support of responses if 
they are distributional, only relevant if \code{methodProj} is \code{'qt'}. 
Default: \code{NULL}, i.e., no finite upper bound.}
}
}
\examples{
\donttest{
# X = N( mu1, sigma1^2 ), Y = N( mu2, sigma2^2 )
# E( mu2 | mu1, sigma1 ) = E(mu2) + b11 ( mu1 - E(mu1) ) + b12 ( sigma1 - E(sigma1) )
# E( sigma2 | mu1, sigma1 ) = E(sigma2) + b21 ( mu1 - E(mu1) ) + b22 ( sigma1 - E(sigma1) )
# E(sigma2) + b21 ( mu1 - E(mu1) ) + b22 ( sigma1 - E(sigma1) ) >= 0 a.s.
# Then beta(s,t) = b11 + b12 ( s - E(mu1) ) / E(sigma1)  + b21 ( t - E(mu2) ) / E(sigma2) + 
# b22 ( ( s - E(mu1) ) / E(sigma1) ) ( ( t - E(mu2) ) / E(sigma2) )
bMat <- matrix( c( 0.5, 0.5, 0.5, -0.5 ), ncol = 2, byrow = TRUE )
n <- 100
# mu1 ~ Beta(2,2)
mu1 <- rbeta( n, 2, 2 ); Emu1 <- 0.5
# sigma1 ~ Uniform(0.5,1.5)
sigma1 <- runif( n, 0.5, 1.5 ); Esigma1 <- 1
# mu2 = E(mu2) + b11 ( mu1 - E(mu1) ) + b12 ( sigma1 - E(sigma1) ) + err_{mu2}
Emu2 <- 2
err_mu2 <- rnorm( n, mean = 0, sd = 0.1 ) # unexplained stochastic part
mu2True <- Emu2 + bMat[1,1] * ( mu1 - Emu1 ) + bMat[1,2] * ( sigma1 - Esigma1 )
mu2 <- mu2True + err_mu2
# sigma2 = E(sigma2) + b21 ( mu1 - E(mu1) ) + b22 ( sigma1 - E(sigma1) ) + err_{sigma2}
Esigma2 <- 2
err_sigma2 <- ( rbeta( n, 2, 2 ) - 0.5 ) / 5 # unexplained stochastic part
sigma2True <- Esigma2 + bMat[2,1] * ( mu1 - Emu1 ) + bMat[2,2] * ( sigma1 - Esigma1 )
sigma2 <- sigma2True + err_sigma2

nqSup <- 1000
qSup <- seq( 0, 1, length.out = nqSup+1 )
qSup <- ( qSup[-1] + qSup[-(nqSup+1)] ) / 2
X <- list(
  X1 = sapply( seq_len(n), function (i) { 
    qnorm( qSup, mean = mu1[i], sd = sigma1[i] ) 
  })
)
QXmean <- list(
  qnorm( qSup, mean = Emu1, sd = Esigma1 )
)
QYmean <- qnorm( qSup, mean = Emu2, sd = Esigma2 )
Y <- sapply( seq_len(n), function (i) { 
  qnorm( qSup, mean = mu2[i], sd = sigma2[i] ) 
})
res <- WR( X = X, Y = Y, qSup = qSup )
}

}
\references{
\cite{Chen, Y., Lin, Z., & Müller, H.-G. (2021). "Wasserstein regression." Journal of the American Statistical Association, in press.}
\cite{Petersen, A., & Müller, H.-G. (2019). "Fréchet regression for random objects with Euclidean predictors." The Annals of Statistics, 47(2), 691--719.}
}
